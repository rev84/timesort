// Generated by CoffeeScript 1.12.7
var check, getElementBoard, getElementButton, getElementModalBoard, getElementModalQuestion, happened2date, init, view;

$().ready(function() {
  init();
  return $('#modal_close').on('click', window.view);
});

view = function() {
  var b, c, card, index, j, ref;
  $('.button, .card').remove();
  if (window.Question === null) {
    $('#question').html('');
  } else {
    $('#question').html(window.Question.title);
  }
  for (index = j = 0, ref = window.Board.length; 0 <= ref ? j < ref : j > ref; index = 0 <= ref ? ++j : --j) {
    card = window.Board[index];
    b = getElementButton(index);
    c = getElementBoard(card);
    $('#board').append(b);
    $('#board').append(c);
  }
  b = getElementButton(window.Board.length);
  return $('#board').append(b);
};

check = function(index) {
  var afterCard, beforeCard, isCorrect, nowCard;
  beforeCard = index === 0 ? null : window.Board[index - 1];
  nowCard = window.Question;
  afterCard = index === window.Board.length ? null : window.Board[index];
  isCorrect = true;
  if (beforeCard !== null && nowCard.happened < beforeCard.happened) {
    isCorrect = false;
  }
  if (afterCard !== null && afterCard.happened < nowCard.happened) {
    isCorrect = false;
  }
  if (isCorrect) {
    $('#modal-title').html('正解！');
  } else {
    $('#modal-title').html('間違い！');
  }
  $('#modal-before').html('');
  if (beforeCard !== null) {
    $('#modal-before').append(getElementModalBoard(beforeCard));
  }
  $('#modal-after').html('');
  if (afterCard !== null) {
    $('#modal-after').append(getElementModalBoard(afterCard));
  }
  $('#modal-now').html('');
  $('#modal-now').append(getElementModalQuestion(nowCard));
  $('#modal_answer').modal('show');
  if (isCorrect) {
    window.Board.splice(index, 0, nowCard);
  }
  return window.Question = window.CurrentCards.pop();
};

getElementBoard = function(card) {
  return $('<div>').addClass('card').append($('<p>').html(card.title));
};

getElementModalBoard = function(card) {
  return $('<div>').addClass('card').append($('<p>').html(card.title)).append($('<p>').html(window.happened2date(card.happened)));
};

getElementModalQuestion = function(card) {
  return $('<div>').addClass('card_question').append($('<p>').html(card.title)).append($('<p>').html(window.happened2date(card.happened))).append($('<p>').html(card.flavorText));
};

getElementButton = function(num) {
  return $('<button>').addClass('btn btn-primary button').html('ここだ！').attr('data-order', num).on('click', function() {
    return window.check(Number($(this).attr('data-order')));
  });
};

happened2date = function(happened) {
  return '' + happened.toString().substr(0, 4) + '年' + happened.toString().substr(4, 2) + '月' + happened.toString().substr(6, 2) + '日';
};

init = function(happenedStart, happenedEnd, tags) {
  var card, cardTag, happenedCards, index, j, l, len, len1, len2, len3, o, q, r, ref, ref1, ref2, tag, taggedCards;
  if (happenedStart == null) {
    happenedStart = null;
  }
  if (happenedEnd == null) {
    happenedEnd = null;
  }
  if (tags == null) {
    tags = [];
  }
  window.Board = [];
  window.Question = null;
  window.CurrentCards = Utl.clone(window.Cards);
  if (tags.length > 0) {
    taggedCards = [];
    for (j = 0, len = tags.length; j < len; j++) {
      tag = tags[j];
      ref = window.CurrentCards;
      for (l = 0, len1 = ref.length; l < len1; l++) {
        card = ref[l];
        ref1 = card.tags;
        for (o = 0, len2 = ref1.length; o < len2; o++) {
          cardTag = ref1[o];
          if (cardTag === tag) {
            taggedCards.push(card);
            break;
          }
        }
      }
    }
    window.CurrentCards = taggedCards;
  }
  if (happenedStart !== null && happenedEnd !== null) {
    happenedCards = [];
    ref2 = window.CurrentCards;
    for (q = 0, len3 = ref2.length; q < len3; q++) {
      card = ref2[q];
      if ((happenedStart <= happened && happened <= happenedEnd)) {
        happenedCards.push(card);
        break;
      }
    }
    window.CurrentCards = happenedCards;
  }
  window.CurrentCards = Utl.shuffle(window.CurrentCards);
  for (index = r = 0; r < 2; index = ++r) {
    window.Board.push(window.CurrentCards.pop());
  }
  window.Question = window.CurrentCards.pop();
  return view();
};

window.Utl = (function() {
  function Utl() {}

  Utl.numFormat = function(num) {
    return String(num).replace(/(\d)(?=(\d\d\d)+(?!\d))/g, '$1,');
  };

  Utl.rand = function(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  };

  Utl.genPassword = function(length) {
    var chars, i, j, ref, res;
    if (length == null) {
      length = 4;
    }
    chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
    res = '';
    for (i = j = 0, ref = length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      res += chars.substr(this.rand(0, chars.length - 1), 1);
    }
    return res;
  };

  Utl.adrBar = function(url) {
    return window.history.replaceState('', '', '' + url);
  };

  Utl.getQuery = function(key, defaultValue) {
    var j, k, len, p, params, query, ref, res, v;
    if (key == null) {
      key = null;
    }
    if (defaultValue == null) {
      defaultValue = null;
    }
    query = document.location.search.substring(1);
    params = query.split('&');
    res = {};
    for (j = 0, len = params.length; j < len; j++) {
      p = params[j];
      ref = p.split('='), k = ref[0], v = ref[1];
      res[k] = v;
    }
    if (key === null) {
      return res;
    }
    if (res[key] != null) {
      return res[key];
    }
    return defaultValue;
  };

  Utl.normalize = function(num, min, max) {
    var range;
    if (min == null) {
      min = 0;
    }
    if (max == null) {
      max = 1;
    }
    range = Math.abs(max - min);
    if (num < min) {
      num += range * Math.ceil(Math.abs(num - min) / range);
    } else if (max <= num) {
      num -= range * (Math.floor(Math.abs(num - max) / range) + 1);
    }
    return num;
  };

  Utl.time = function(date) {
    if (date == null) {
      date = null;
    }
    if (date === null) {
      date = new Date();
    }
    return Math.floor(+date / 1000);
  };

  Utl.militime = function(date, getAsFloat) {
    if (date == null) {
      date = null;
    }
    if (getAsFloat == null) {
      getAsFloat = false;
    }
    if (date === null) {
      date = new Date();
    }
    return +date / (getAsFloat ? 1000 : 1);
  };

  Utl.dateStr = function(date, dateSep) {
    if (date == null) {
      date = null;
    }
    if (dateSep == null) {
      dateSep = '-';
    }
    if (date === null) {
      date = new Date();
    }
    return '' + this.zerofill(date.getFullYear(), 4) + dateSep + this.zerofill(date.getMonth() + 1, 2) + dateSep + this.zerofill(date.getDate(), 2);
  };

  Utl.datetimeStr = function(date, dateSep, timeSep, betweenSep) {
    if (date == null) {
      date = null;
    }
    if (dateSep == null) {
      dateSep = '-';
    }
    if (timeSep == null) {
      timeSep = ':';
    }
    if (betweenSep == null) {
      betweenSep = ' ';
    }
    if (date === null) {
      date = new Date();
    }
    return this.dateStr(date, dateSep) + betweenSep + this.zerofill(date.getHours(), 2) + timeSep + this.zerofill(date.getMinutes(), 2) + timeSep + this.zerofill(date.getSeconds(), 2);
  };

  Utl.difftime = function(targetDate, baseDate, nowSec, nowStr, agoStr, secStr, minStr, hourStr, dayStr, monStr, yearStr) {
    var baseTime, d, diffTime, h, m, mo, targetTime, y;
    if (baseDate == null) {
      baseDate = null;
    }
    if (nowSec == null) {
      nowSec = 0;
    }
    if (nowStr == null) {
      nowStr = 'ついさっき';
    }
    if (agoStr == null) {
      agoStr = '前';
    }
    if (secStr == null) {
      secStr = '秒';
    }
    if (minStr == null) {
      minStr = '分';
    }
    if (hourStr == null) {
      hourStr = '時間';
    }
    if (dayStr == null) {
      dayStr = '日';
    }
    if (monStr == null) {
      monStr = '月';
    }
    if (yearStr == null) {
      yearStr = '年';
    }
    if (baseDate === null) {
      baseTime = this.time();
    }
    targetTime = this.time(targetDate);
    diffTime = baseTime - targetTime;
    if (diffTime < 0) {
      return null;
    }
    if (nowSec >= diffTime) {
      return nowStr;
    }
    y = Math.floor(diffTime / (60 * 60 * 24 * 30 * 12));
    if (y > 0) {
      return '' + y + yearStr + agoStr;
    }
    diffTime -= y * (60 * 60 * 24 * 30 * 12);
    mo = Math.floor(diffTime / (60 * 60 * 24 * 30));
    if (mo > 0) {
      return '' + mo + monStr + agoStr;
    }
    diffTime -= mo * (60 * 60 * 24 * 30);
    d = Math.floor(diffTime / (60 * 60 * 24));
    if (d > 0) {
      return '' + d + dayStr + agoStr;
    }
    diffTime -= d * (60 * 60 * 24);
    h = Math.floor(diffTime / (60 * 60));
    if (h > 0) {
      return '' + h + hourStr + agoStr;
    }
    diffTime -= h * (60 * 60);
    m = Math.floor(diffTime / 60);
    if (m > 0) {
      return '' + m + minStr + agoStr;
    }
    diffTime -= m * 60;
    if (diffTime > 0) {
      return '' + diffTime + secStr + agoStr;
    }
    return nowStr;
  };

  Utl.zerofill = function(num, digit) {
    return ('' + this.repeat('0', digit) + num).slice(-digit);
  };

  Utl.repeat = function(str, times) {
    return Array(1 + times).join(str);
  };

  Utl.shuffle = function(ary) {
    var i, n, ref;
    n = ary.length;
    while (n) {
      n--;
      i = this.rand(0, n);
      ref = [ary[n], ary[i]], ary[i] = ref[0], ary[n] = ref[1];
    }
    return ary;
  };

  Utl.inArray = function(needle, ary) {
    var j, len, v;
    for (j = 0, len = ary.length; j < len; j++) {
      v = ary[j];
      if (v === needle) {
        return true;
      }
    }
    return false;
  };

  Utl.clone = function(obj) {
    var res;
    res = obj;
    if ($.isArray(obj)) {
      res = $.extend(true, [], obj);
    } else if (obj instanceof Object) {
      res = $.extend(true, {}, obj);
    }
    return res;
  };

  Utl.arrayFill = function(length, val) {
    var i, j, ref, res;
    if (val == null) {
      val = null;
    }
    res = [];
    for (i = j = 0, ref = length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      res[i] = this.clone(val);
    }
    return res;
  };

  Utl.array2dFill = function(x, y, val) {
    var j, l, ref, ref1, res, xx, yAry, yy;
    if (y == null) {
      y = null;
    }
    if (val == null) {
      val = null;
    }
    if (y === null) {
      y = x;
    }
    res = [];
    yAry = [];
    for (yy = j = 0, ref = y; 0 <= ref ? j < ref : j > ref; yy = 0 <= ref ? ++j : --j) {
      yAry[yy] = this.clone(val);
    }
    for (xx = l = 0, ref1 = x; 0 <= ref1 ? l < ref1 : l > ref1; xx = 0 <= ref1 ? ++l : --l) {
      res[xx] = this.clone(yAry);
    }
    return res;
  };

  Utl.arraySum = function(ary) {
    var j, len, sum, v;
    sum = 0;
    for (j = 0, len = ary.length; j < len; j++) {
      v = ary[j];
      sum += v;
    }
    return sum;
  };

  Utl.arrayMin = function(ary) {
    var j, len, min, v;
    min = null;
    for (j = 0, len = ary.length; j < len; j++) {
      v = ary[j];
      if (min === null || min > v) {
        min = v;
      }
    }
    return min;
  };

  Utl.arrayMax = function(ary) {
    var j, len, max, v;
    max = null;
    for (j = 0, len = ary.length; j < len; j++) {
      v = ary[j];
      if (max === null || max < v) {
        max = v;
      }
    }
    return max;
  };

  Utl.count = function(object) {
    return Object.keys(object).length;
  };

  Utl.uuid4 = function() {
    var i, j, random, uuid;
    uuid = '';
    for (i = j = 0; j < 32; i = ++j) {
      random = Math.random() * 16 | 0;
      if (i === 8 || i === 12 || i === 16 || i === 20) {
        uuid += '-';
      }
      uuid += (i === 12 ? 4 : (i === 16 ? random & 3 | 8 : random)).toString(16);
    }
    return uuid;
  };

  Utl.delLs = function(key) {
    return localStorage.removeItem(key);
  };

  Utl.setLs = function(key, value) {
    var json;
    if (value == null) {
      value = null;
    }
    if (value === null) {
      return this.delLs(key);
    }
    json = JSON.stringify(value);
    return localStorage.setItem(key, json);
  };

  Utl.getLs = function(key) {
    var res;
    res = localStorage.getItem(key);
    try {
      res = JSON.parse(res);
    } catch (error) {
      res = null;
    }
    return res;
  };

  Utl.sleep = function(msec) {
    return new Promise((function(_this) {
      return function(resolve, reject) {
        return setTimeout(function() {
          return resolve();
        }, msec);
      };
    })(this));
  };

  Utl.IndexedDB = (function() {
    IndexedDB.prototype.STORE_NAME = 'default';

    IndexedDB.prototype.LOCK_WAIT_MSEC = 50;

    IndexedDB.prototype.TIMEOUT_MSEC = 5000;

    function IndexedDB(dbName, dbVersion) {
      var open;
      this.dbName = dbName != null ? dbName : 'default';
      this.dbVersion = dbVersion != null ? dbVersion : 1;
      this.db = null;
      open = window.indexedDB.open(this.dbName, this.dbVersion);
      open.onupgradeneeded = (function(_this) {
        return function(evt) {
          var res;
          res = evt.target.result;
          return res.createObjectStore(_this.STORE_NAME, {
            keyPath: 'kvstore_key'
          });
        };
      })(this);
      open.onsuccess = (function(_this) {
        return function(evt) {
          return _this.db = evt.target.result;
        };
      })(this);
    }

    IndexedDB.prototype.set = function(key, value) {
      var db, request, store, token, transaction;
      await(this.waitUnLock());
      token = this.genToken();
      this.lock(token);
      db = await(this.getDB());
      transaction = db.transaction(this.STORE_NAME, 'readwrite');
      store = transaction.objectStore(this.STORE_NAME);
      request = store.put({
        kvstore_key: key,
        kvstore_value: JSON.stringify(value)
      });
      request.onsuccess = (function(_this) {
        return function(evt) {
          if (token === _this.token) {
            return _this.capture(true, token);
          } else {
            return _this.capture(false, token);
          }
        };
      })(this);
      request.onerror = (function(_this) {
        return function(evt) {
          return _this.capture(false, token);
        };
      })(this);
      await(this.waitCapture());
      if (token === this.token && this.isCaptured) {
        return this.unlock(token);
      } else {
        return false;
      }
    };

    IndexedDB.prototype.get = function(key) {
      var db, request, store, token, transaction;
      await(this.waitUnLock());
      token = this.genToken();
      this.lock(token);
      db = await(this.getDB());
      transaction = db.transaction(this.STORE_NAME, 'readonly');
      store = transaction.objectStore(this.STORE_NAME);
      request = store.get(key);
      request.onsuccess = (function(_this) {
        return function(evt) {
          var res;
          try {
            res = JSON.parse(evt.target.result.kvstore_value);
          } catch (error) {
            res = null;
          }
          if (token === _this.token) {
            return _this.capture(res, token);
          } else {
            return _this.unlock(token);
          }
        };
      })(this);
      await(this.waitCapture());
      if (this.isCaptured) {
        return this.unlock(token);
      } else {
        return null;
      }
    };

    IndexedDB.prototype.gets = function(keys) {
      var db, j, key, len, request, res, store, token, transaction;
      await(this.waitUnLock());
      token = this.genToken();
      this.lock(token);
      res = {};
      db = await(this.getDB());
      transaction = db.transaction(this.STORE_NAME, 'readonly');
      store = transaction.objectStore(this.STORE_NAME);
      for (j = 0, len = keys.length; j < len; j++) {
        key = keys[j];
        request = store.get(key);
        request.onsuccess = (function(_this) {
          return function(evt) {
            try {
              return res[evt.target.result.kvstore_key] = JSON.parse(evt.target.result.kvstore_value);
            } catch (error) {
              return res[evt.target.result.kvstore_key] = null;
            }
          };
        })(this);
      }
      transaction.oncomplete = (function(_this) {
        return function(evt) {
          return _this.capture(res, token);
        };
      })(this);
      await(this.waitCapture());
      if (this.isCaptured) {
        return this.unlock(token);
      } else {
        return null;
      }
    };

    IndexedDB.prototype.getAllKeys = function() {
      var db, keys, request, store, token, transaction;
      await(this.waitUnLock());
      token = this.genToken();
      this.lock(token);
      keys = [];
      db = await(this.getDB());
      transaction = db.transaction(this.STORE_NAME, 'readonly');
      store = transaction.objectStore(this.STORE_NAME);
      request = store.openCursor();
      request.onsuccess = (function(_this) {
        return function(evt) {
          var cursor;
          cursor = evt.target.result;
          if (cursor) {
            keys.push(cursor.key);
            return cursor["continue"]();
          } else {
            return _this.capture(keys, token);
          }
        };
      })(this);
      request.onerror = (function(_this) {
        return function(evt) {
          return _this.unlock(token);
        };
      })(this);
      await(this.waitCapture());
      if (this.isCaptured) {
        return this.unlock(token);
      } else {
        return [];
      }
    };

    IndexedDB.prototype.destroy = function() {
      return window.indexedDB.deleteDatabase(this.dbName);
    };

    IndexedDB.prototype.unlock = function(token) {
      var res;
      if (token == null) {
        token = null;
      }
      if (token === null || token === this.token) {
        res = this.result;
        this.result = null;
        this.isCaptured = false;
        this.locked = null;
        this.token = null;
        this.isLocked = false;
        return res;
      } else {
        return null;
      }
    };

    IndexedDB.prototype.capture = function(value, token) {
      if (this.token === token) {
        this.isLocked = true;
        this.isCaptured = true;
        return this.result = value;
      }
    };

    IndexedDB.prototype.lock = function(token) {
      this.isLocked = true;
      this.token = token;
      this.isCaptured = false;
      this.locked = +(new Date());
      this.result = null;
      return true;
    };

    IndexedDB.prototype.waitUnLock = function() {
      while (this.isLocked && +(new Date()) - this.locked < this.TIMEOUT_MSEC) {
        await(Utl.sleep(this.LOCK_WAIT_MSEC));
      }
      return true;
    };

    IndexedDB.prototype.waitCapture = function() {
      while (!this.isCaptured && +(new Date()) - this.locked < this.TIMEOUT_MSEC) {
        await(Utl.sleep(this.LOCK_WAIT_MSEC));
      }
      return true;
    };

    IndexedDB.prototype.waitInitialized = function() {
      while (this.isInitialized && +(new Date()) - this.locked < this.TIMEOUT_MSEC) {
        await(Utl.sleep(this.LOCK_WAIT_MSEC));
      }
      return true;
    };

    IndexedDB.prototype.genToken = function() {
      return '' + (+new Date()) + Utl.genPassword(128);
    };

    IndexedDB.prototype.getDB = function() {
      while (this.db === null) {
        await(Utl.sleep(this.LOCK_WAIT_MSEC));
      }
      return this.db;
    };

    return IndexedDB;

  })();

  return Utl;

})();
